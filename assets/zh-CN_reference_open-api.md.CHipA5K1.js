import{_ as a,C as o,o as l,c as n,ae as d,E as s,w as i,a as c}from"./chunks/framework.f9sx20OT.js";const _=JSON.parse('{"title":"开放接口 (OpenAPI) 指南","description":"","frontmatter":{},"headers":[],"relativePath":"zh-CN/reference/open-api.md","filePath":"zh-CN/reference/open-api.md","lastUpdated":1769480114000}'),r={name:"zh-CN/reference/open-api.md"};function p(g,e,h,u,f,x){const t=o("callout");return l(),n("div",null,[e[1]||(e[1]=d(`<h1 id="开放接口-openapi-指南" tabindex="-1">开放接口 (OpenAPI) 指南 <a class="header-anchor" href="#开放接口-openapi-指南" aria-label="Permalink to &quot;开放接口 (OpenAPI) 指南&quot;">​</a></h1><p>PieMDM 提供了强大的 OpenAPI，允许外部系统通过安全认证的方式访问主数据。OpenAPI 采用了基于规范请求（Canonical Request）的 HMAC-SHA256 签名机制，确保请求的真实性和完整性。</p><h2 id="_1-认证机制" tabindex="-1">1. 认证机制 <a class="header-anchor" href="#_1-认证机制" aria-label="Permalink to &quot;1. 认证机制&quot;">​</a></h2><p>所有 OpenAPI 请求必须在 Header 中携带以下认证参数：</p><table tabindex="0"><thead><tr><th style="text-align:left;">Header 参数</th><th style="text-align:left;">说明</th><th style="text-align:left;">示例</th></tr></thead><tbody><tr><td style="text-align:left;"><code>X-App-Id</code></td><td style="text-align:left;">应用标识，在“应用管理”中获取</td><td style="text-align:left;"><code>app_592837482...</code></td></tr><tr><td style="text-align:left;"><code>X-Timestamp</code></td><td style="text-align:left;">请求发送时的 Unix 时间戳（秒）</td><td style="text-align:left;"><code>1674829374</code></td></tr><tr><td style="text-align:left;"><code>X-Nonce</code></td><td style="text-align:left;">长度至少 16 位的随机字符串，用于防重放攻击</td><td style="text-align:left;"><code>abcdef1234567890</code></td></tr><tr><td style="text-align:left;"><code>X-Sign</code></td><td style="text-align:left;">根据签名算法计算出的摘要值（Hex 编码）</td><td style="text-align:left;"><code>a1b2c3d4...</code></td></tr></tbody></table><h3 id="_1-1-签名算法" tabindex="-1">1.1 签名算法 <a class="header-anchor" href="#_1-1-签名算法" aria-label="Permalink to &quot;1.1 签名算法&quot;">​</a></h3><p>签名的计算过程如下：</p><ol><li><p><strong>构造规范请求字符串 (Canonical Request)</strong>： 格式为各部分由换行符 <code>\\n</code> 连接：</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>HTTPMethod + &quot;\\n&quot; +</span></span>
<span class="line"><span>CanonicalURI + &quot;\\n&quot; +</span></span>
<span class="line"><span>CanonicalQueryString + &quot;\\n&quot; +</span></span>
<span class="line"><span>SHA256(RequestBody) + &quot;\\n&quot; +</span></span>
<span class="line"><span>X-Timestamp + &quot;\\n&quot; +</span></span>
<span class="line"><span>X-Nonce</span></span></code></pre></div><ul><li><strong>HTTPMethod</strong>: 大写的 HTTP 方法，如 <code>GET</code> 或 <code>POST</code>。</li><li><strong>CanonicalURI</strong>: 请求的完整路径，必须以 <code>/</code> 开头，如 <code>/openapi/v1/entities/users</code>。</li><li><strong>CanonicalQueryString</strong>: 排序后的查询参数字符串。按参数名 ASCII 升序排列，格式为 <code>key1=value1&amp;key2=value2</code>。</li><li><strong>SHA256(RequestBody)</strong>: 请求体的 SHA256 哈希值（小写 Hex）。若 Body 为空，则哈希值为：<code>e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855</code>。</li><li><strong>X-Timestamp</strong> 和 <strong>X-Nonce</strong>: 与 Header 中的值保持严格一致。</li></ul></li><li><p><strong>计算签名</strong>： 使用应用的 <code>AppSecret</code> 作为 Key，对上述规范字符串进行 HMAC-SHA256 计算：</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Signature = Hex(HMAC-SHA256(AppSecret, CanonicalRequest))</span></span></code></pre></div></li></ol><h2 id="_2-安全策略" tabindex="-1">2. 安全策略 <a class="header-anchor" href="#_2-安全策略" aria-label="Permalink to &quot;2. 安全策略&quot;">​</a></h2><p>除了签名验证，OpenAPI 还提供了多重安全保障：</p><ul><li><strong>IP 白名单</strong>：只有在“应用管理”中配置的白名单 IP 才能成功调用接口。</li><li><strong>权限审计</strong>：所有 OpenAPI 的调用都会被详细记录，包括请求参数、响应结果、调用耗时等。</li><li><strong>Nonce 防重放</strong>：每个 Nonce 仅能使用一次。系统会缓存最近使用的 Nonce，重复提交将返回 <code>401 Unauthorized</code>。</li><li><strong>时间窗口校验</strong>：<code>X-Timestamp</code> 与服务器当前时间的偏差超过 5 分钟将被拒绝。</li></ul><h2 id="_3-核心接口" tabindex="-1">3. 核心接口 <a class="header-anchor" href="#_3-核心接口" aria-label="Permalink to &quot;3. 核心接口&quot;">​</a></h2><p>所有接口的基础路径为：<code>/openapi/v1</code></p><h3 id="_3-1-获取实体列表" tabindex="-1">3.1 获取实体列表 <a class="header-anchor" href="#_3-1-获取实体列表" aria-label="Permalink to &quot;3.1 获取实体列表&quot;">​</a></h3><p><strong>GET</strong> <code>/openapi/v1/entities/{table_code}</code></p><p><strong>查询参数</strong>：</p><ul><li><code>page</code>: 页码，默认 1</li><li><code>pageSize</code>: 每页数量，默认 15，最大 100</li><li><code>id</code>: 可选，精确过滤 ID</li><li><code>status</code>: 可选，状态过滤</li><li><code>created_at</code>: 可选，创建时间过滤</li></ul><h3 id="_3-2-获取实体详情" tabindex="-1">3.2 获取实体详情 <a class="header-anchor" href="#_3-2-获取实体详情" aria-label="Permalink to &quot;3.2 获取实体详情&quot;">​</a></h3><p><strong>GET</strong> <code>/openapi/v1/entities/{table_code}/{id}</code></p><h2 id="_4-错误码参考" tabindex="-1">4. 错误码参考 <a class="header-anchor" href="#_4-错误码参考" aria-label="Permalink to &quot;4. 错误码参考&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:left;">错误消息</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;"><code>AUTH_FAILED</code></td><td style="text-align:left;"><code>X-App-Id</code> 无效或缺失</td></tr><tr><td style="text-align:left;"><code>SIGNATURE_INVALID</code></td><td style="text-align:left;">签名验证失败</td></tr><tr><td style="text-align:left;"><code>TOKEN_EXPIRED</code></td><td style="text-align:left;">时间戳超时或 Nonce 已被使用</td></tr><tr><td style="text-align:left;"><code>IP_NOT_ALLOWED</code></td><td style="text-align:left;">客户端 IP 不在白名单中</td></tr><tr><td style="text-align:left;"><code>PERMISSION_DENIED</code></td><td style="text-align:left;">应用无权访问指定的实体表</td></tr></tbody></table>`,21)),s(t,{emoji:"💡","background-color":"light-blue","border-color":"blue"},{default:i(()=>[...e[0]||(e[0]=[c(" 提示：更多接口（如创建、修改实体）正在开发中。如有紧急需求，请联系技术支持。 ",-1)])]),_:1})])}const y=a(r,[["render",p]]);export{_ as __pageData,y as default};
